--require("utils")
os.loadAPI("utils")

local args = {...}

dependencies = {}
dependencies['utils'] = "https://raw.githubusercontent.com/MaxTheMooshroom/computercraft-scripts/master/utils"
dependencies['sha1'] = "http://regex.info/code/sha1.lua"
dependencies['json'] = "https://pastebin.com/raw/4nRg9CHU"

-- Begin Commands:
commands = {}
_G.commands = commands

function checkDependencies()
    local missing = {}
    for f, l in pairs(dependencies) do
        if not fs.exists(f) then
            missing[#missing + 1] = f
        end
    end
    return missing
end

function commands.checkDependencies()
    print(textutils.serialize(checkDependencies()))
end

function commands.installDependency(dep)
    if fs.exists(dep) then
        print("\""..dep.."\" is already installed...")
        return
    end
    if dependencies[dep] ~= nil then
        print("downloading \""..dep.."\"...")
        local data = utils.wrapRequest(dependencies[dep])
        print("installing \""..dep.."\"...")
        local file = fs.open(dep, 'w')
        file.write(data)
        file.close()
        print("Done!\n")
    end
end

function commands.installDependencies()
    local missing = checkDependencies()
    for i=1,#missing do
        commands.installDependency(missing[i])
    end
end

function commands.loadDependencies()
    local missing = checkDependencies()
    for f, l in pairs(dependencies) do -- for each dependency
        if not utils.containsValue(missing, f) then -- if the dependency isn't missing
            os.loadAPI(f) -- load the dependency
        end
    end
end

function commands.shell(str)
    shell.run(str)
end

function commands.lua(str)
    if str == nil then
        shell.run('lua')
    else
        loadstring(str)()
    end
end

function commands.clear()
    shell.run("clear")
    utils.printWithFormat("&2MTMOS V0.0.1")
end

function commands.help()
    local count = 0
    for i in pairs(commands) do count = count + 1 end
    utils.printWithFormat("&1Commands found: "..tostring(count))
    for k in utils.sortedKeys(commands) do
        print(k)
    end
    print()
end

-- End commands

-- function for finding a function given its name as a string
function findfunction(x)
  assert(type(x) == "string")
  local f=_G
  for v in x:gmatch("[^%.]+") do
    if type(f) ~= "table" then
       return nil, "looking for '"..v.."' expected table, not "..type(f)
    end
    f=f[v]
  end
  if type(f) == "function" then
    return f, nil
  else
    return nil, "expected function, not "..type(f)
  end
end

-- find missing dependencies
local miss = checkDependencies()
if #miss > 0 then
    for name = 1, #miss do
        utils.printWithFormat("&0[&1WARNING&0]: Missing dependency: "..miss[name])
    end
    utils.printWithFormat("&0Please run the dependency installer with \n'&2installDependencies&0'")
    print()
end
-- end search

commands.loadDependencies()

-- Coroutine Manager
CoroutineManager = {}
_G.CoroutineManager = CoroutineManager
CoroutineManager.listeners = {}
CoroutineManager.addListener = function(func, event)
    if type(func) ~= "thread" then
        error("func must be a coroutine. Please use coroutine.create(func)")
    end
    CoroutineManager.listeners[func] = event
end
CoroutineManager.main = function(...)
    while true do
        local event_type, p1, p2, p3, p4, p5 = os.pullEvent()
        if event_type ~= "key" and event_type ~= "char" and event_type ~= "key_up" then
            print('Erroneous event triggered: '..event_type)
        end
        --print("event: "..event_type)
        for k, v in pairs(CoroutineManager.listeners) do
            if event_type == v then
                --print(v)
                local status, result = coroutine.resume(k, p1, p2, p3, p4, p5)
                if result == "exit" then
                    return
                end
            end
        end
    end
end
-- end Coroutine Manager

-- Native Coroutines
local shell_input_buffer = ""
function shell_routine(p1, p2, p3, p4, p5) -- char event
    term.setCursorBlink(true)
    io.write('$ ')
    while true do
        -- print(p1)
        io.write(p1)
        shell_input_buffer = shell_input_buffer..p1
        p1, p2, p3, p4, p5 = coroutine.yield()
    end
end

local shell_routine_coroutine = coroutine.create(shell_routine)

CoroutineManager.addListener(shell_routine_coroutine, "char")

function shell_key_routine(p1, p2, p3, p4, p5) -- key event
    while true do
        --print('test')
        if p1 == keys.enter then
            print()
            local args = utils.split(shell_input_buffer)
            local command = args[1]

            table.remove(args, 1)

            if command == "exit" then coroutine.yield("exit") end
            local func, err = findfunction('commands.'..command)

            if err ~= nil then
                print("Could not find command \""..command.."\"")
                print(err)
            else
                if #args == 0 then
                    func()
                else
                    func(utils.join(args))
                end
                --print("hit2")
            end
            shell_input_buffer = ''
            io.write('$ ')
        elseif p1 == keys.backspace then
            shell_input_buffer = shell_input_buffer:sub(1, -2)
        end
        p1, p2, p3, p4, p5 = coroutine.yield()
    end
end
CoroutineManager.addListener(coroutine.create(shell_key_routine), "key")
-- End Native Coroutines
if args[1] == 'run' then
    shell.run("clear")
    utils.printWithFormat("&2MTMOS V0.0.1")

    coroutine.resume(shell_routine_coroutine, '')

    CoroutineManager.main()
end
